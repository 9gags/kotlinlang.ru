---
type: doc
layout: reference
category: "Syntax"
title: "Управляющие инструкции"
url: https://kotlinlang.ru/docs/reference/control-flow.html
---

# Управляющие инструкции

## Условное выражение If

В языке Kotlin, ключевое слово **if**<!--keyword--> является выражение, т.е. оно возвращает значение.
Это позволяет отказаться от тернарного оператора (условие ? условие истинно : условие ложно), поскольку выражению **if**<!--keyword--> по силам его заменить.

``` kotlin
// обычное использование 
var max = a 
if (a < b) 
  max = b 
 
// с блоком else 
var max: Int
if (a > b) 
  max = a 
else 
  max = b 
 
// в виде выражения 
val max = if (a > b) a else b
```

"Ветви" выражения **if**<!--keyword--> могут содержать несколько строк кода, при этом при этом последнее выражение является значением блока:

``` kotlin
val max = if (a > b) { 
    print("возвращаем a") 
    a 
  } 
  else { 
    print("возвращаем b") 
    b 
  }
```

Если вы используете конструкцию **if**<!--keyword--> в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` является обязательным.

См. [использование **if**<!--keyword-->](grammar.html#if).

## Условное выражение when

Ключевое слово **when**<!--keyword--> призвано заменить оператор switch, присутствующий в C-подобных языках. В простейшем виде его использование выглядит так

``` kotlin
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> { // обратите внимание на блок
    print("x is neither 1 nor 2")
  }
}
```

Выражение **when**<!--keyword--> последовательно сравнивает аргумент со всеми указанными значениями до удовлетворения одного из условий.
**when**<!--keyword--> можно использовать и как выражение, и как оператор. При использовании в виде выражения значение ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора, значения отдельных веток отбрасываются. (В точности как **if**<!--keyword-->: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.)

Значение ветки **else**<!--keyword--> вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.
Если **when**<!--keyword--> используется как выражение, то ветка **else**<!--keyword--> является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. 


Если для нескольких значений выполняется одно и тоже действие, то условия можно перечислять в одной ветке через запятую:

``` kotlin
when (x) {
  0, 1 -> print("x == 0 or x == 1")
  else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения

``` kotlin
when (x) {
  parseInt(s) -> print("s encodes x")
  else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в [промежуток](ranges.html) **in**<!--keyword--> или **!in**<!--keyword--> или его наличие в коллекции:

``` kotlin
when (x) {
  in 1..10 -> print("x is in the range")
  in validNumbers -> print("x is valid")
  !in 10..20 -> print("x is outside the range")
  else -> print("none of the above")
}
```

Помимо этого Кotlin позволяет с момощью **is**<!--keyword--> or **!is**<!--keyword--> проверить тип аргумента. Обратите внимание, что благодаря [smart casts](typecasts.html#smart-casts), вы можете получить доступ к методам и свойствам типа без дополнительной проверки.

```kotlin
val hasPrefix = when(x) {
  is String -> x.startsWith("prefix")
  else -> false
}
```

**when**<!--keyword--> удобно использовать вместо цепочки условий вида **if**<!--keyword-->-**else**<!--keyword--> **if**<!--keyword-->. При отстутствии аргумента, условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

``` kotlin
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

См. [использование **when**<!--keyword-->](grammar.html#when).


## Циклы for

Цикл **for**<!--keyword--> обеспечивает перебор всех значений, поставляемых итератором. Для этого используется следующий синтаксис:

``` kotlin
for (item in collection)
  print(item)
```

Телом цикла может быть блок кода:

``` kotlin
for (item: Int in ints) {
  // ...
}
```

Как отмечено выше, цикл **for**<!--keyword--> позволяет проходить по всем элементам объекта, имеющего итератор, например:

* обладающего внутренней или внешней функцией `iterator()`, возвращаемый тип которой
  * обладает внутренней или внешней функцией `next()`, и
  * обладает внутренней или внешней функцией `hasNext()`, возвращающей `Boolean`.

Все три указанные функции должны быть объявлены как `operator`.

Если при проходе по массиву или списку необходим порядковый номер элемента, используйте следующий подход:

``` kotlin
for (i in array.indices)
  print(array[i])
```

Обратите внимание, что данная "итерация по ряду" компилируется в более производительный код без создания дополнительных объектов.

Также вы можете использовать библиотечную функцию `withIndex`:

``` kotlin
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

См. [использование **for**<!--keyword-->](grammar.html#for).

## Циклы while

Ключевые слова **while**<!--keyword--> and **do**<!--keyword-->..**while**<!--keyword--> работают как обычно:

``` kotlin
while (x > 0) {
  x--
}

do {
  val y = retrieveData()
} while (y != null) // y is visible here!
```

См. [использование **while**<!--keyword-->](grammar.html#while).

## Ключевые слова break и continue в циклах

Kotlin поддерживает обычные операторы **break**<!--keyword--> и **continue**<!--keyword--> в циклах. См. [Returns and jumps](returns.html).


